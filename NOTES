
This file will be used to document the technologies and concepts used (and learnt) during the making of this app. 
This document also includes links (journals, documents and videos) that were used during the research process. 
Languages: HTML, CSS, Javascript

BACKEND
Technologies Used:
MongoDB, Mongoose (library), MongoDB Compass
NodeJS
Express
Postman

FRONTEND
Technologies Used:
React
Redux
Heroku (attempted to deploy)
Axiom (http client for frontend?)


scripts: Heroku-Postbuild
packages: colors, path(NodeJS), NPM
Frameworks: express, react, redux?


NPM - Node Package Manager:
World's largest software registry. Open source developers use npm to share and borrow packages, 
and many organizations use npm to manage private development. npm consists of three distinct components:
1.the website
2. the Command Line Interface (CLI)
3. the registry
https://docs.npmjs.com/about-npm

Express:
Express is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications.
https://expressjs.com/

Postman:
Postman is an API platform for building and using APIs.
To run a simple request to the server:
1. Create server.js
2. Run server.js on terminal: npm run server 
3. Run file that contains code to make request (in this case Postman).
https://www.youtube.com/watch?v=VywxIQ2ZXw4

Mongoose:
In simple terms, it is a JavaScript object-oriented programming library that creates a connection between MongoDB and the Express web application framework.
It interacts with routes (client requests and server responses).
Mongoose is our ODM, which means it works like a non-relational/NoSQL database.
https://www.mongodb.com/developer/article/mongoose-versus-nodejs-driver/

JWT - JSON Web Token:
JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties.
The JWT can be encoded or decoded and consists of 3 parts: 
1. header: includes algorithm and token type (JWT is the type)
2. payload: Includes data in json format; can have whatever you want in the token. In our case, we include the user id.
            iat: Time the token was issued at
3. verify signature: ensures JWT has not been altered or tampered
The party that creates the token signs the header and payload with a secret that is known to both issuer and receiver OR a private key known only to issuer.
This means if we wanted to access a protected route we will have to send the token/header to access that specific protected route.

R.E.S.T. :
What does REST stand for? https://stackoverflow.com/questions/671118/what-exactly-is-restful-programming


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CONCEPTS

Try & Catch (errors):
The try statement allows you to define a block of code to be tested for errors while it is being executed.
The catch statement allows you to define a block of code to be executed, if an error occurs in the try block.
https://www.w3schools.com/js/js_errors.asp

Async Functions:
All Mongoose methods are Asynchronous (they return a 'promise'). An async function is a function declared with the 'async' keyword, 
and the 'await' keyword is permitted within it. 
The 'async' & 'await' keywords enable asynchronous, promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function

Promise chaining:
Promise chaining is a syntax that allows you to chain together multiple asynchronous tasks in a specific order. 
This is great for complex code where one asynchronous task needs to be performed after the completion of a different asynchronous task.
https://javascript.info/promise-chaining
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises

Routes:
To create a route we need an http client (ex. Postman), where we specify: 
1. Request: GET, PUT, POST, DELETE, etc. 
2. Server address: http://localhost:5000/api/goals (this gets goals)

ex. of route in javascript:
app.get('/api/goals', (req, res) =>{
    res.status(200).json({message: 'Get Goals' })
})
Where 'get' is the request type we are listening for, and '/api/goals' is the endpoint. 
Asynchronous functions send a string as a response (usually json object or array). It is also good practice to set a status.
We usually have more than one route, so we make a separate folder and files in the backend separating them.
Each resource in the API should have its own route file.
https://expressjs.com/en/starter/basic-routing.html

Middleware:
are functions that runs during the req/res cycle.
https://expressjs.com/en/guide/writing-middleware.html#:~:text=Overview,the%20application's%20request%2Dresponse%20cycle.&text=Middleware%20functions%20can%20perform%20the,request%20and%20the%20response%20objects.

API:

Databases:
Relational (SQL) VS non-relational (No-SQL) databases:
Relational databases are held in the traditional chart like formats whereas non-relational are held in documents. 
In this sense, A “collection” of “documents” in a MongoDB database is analogous to a “table” of “rows” in a relational database.
We will be using a No-SQL database (MongoDB) for this project.

ORM vs. ODM :
An ORM (Object Relational Mapping) maps between an Object Model and a Relational Database. 
An ODM (Object Data Modelling) maps between an Object Model and a Document Database. 
MySQL is not an ORM it's a Relational Database, more specifically a SQL Database. MongoDB is not an ODM, it's a Document Database.
In terms of Node.js, mongodb is the native driver for interacting with a mongodb instance and mongoose is an Object modeling tool for MongoDB.
Mongoose is built on top of the mongodb driver to help programmers model their data, but Mongodb can still be used for the same purpose.
https://stackoverflow.com/questions/12261866/what-is-the-difference-between-an-orm-and-an-odm
https://stackoverflow.com/questions/28712248/difference-between-mongodb-and-mongoose

Schema:
Mongoose Timestamps: https://masteringjs.io/tutorials/mongoose/timestamps
Quick Schema example: https://mongoosejs.com/docs/index.html
schema: https://mongoosejs.com/docs/guide.html
schema types: https://mongoosejs.com/docs/schematypes.html
Videos on Schema design best practices: 
https://www.youtube.com/watch?v=leNCfU5SYR8 (longer version)
https://www.youtube.com/watch?v=QAqK-R9HUhc (shorter version)

Encryption
To make our registerUser functionality (in userController.js), 
we need to encrypt our passwords and store the encryptions 
(never store plain text passwords, very easy to hack!)
To help encrypt we will use bcrypt and json webtokens: 
npm i bcryptjs
npm i jsonwebtoken
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

STATUSES
404 - not found
200 - OK
400 - Bad request, client error (server cant understand)
401 - Unauthorized
500 - server error

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FILES & FOLDERS
backend/
server.js: Basic express server.
config/db.js: connects to database created and linked in .env file under variable 'MONGO_URI' using Mongoose
models: The 'models' folder is where we define any resources we have (blog posts, to do's, etc., whatever we have in our application)
            It's files is where we define our schemas, which will be the fields for particular resources
            The schema is defined using Mongoose.
models/goalModel.js:  goal schema.
models/userModel.js:  user schema.
routes: Imports these functions from the controller and protects the routes using the authentication middleware.
routes/goalRoutes.js: 4 protected routes (2x '/' & 2x '/:id') with functions (getGoals/get, setGoal/post, updateGoal/put, deleteGoal/delete - AKA CRUD method). 
            Id of user in route is needed to find the goal for that specific user so it can be updated or deleted.
routes/userRoutes.js: 3 routes, 1 protected ('/', '/login', '/me') with functions (registerUser/post, loginUser/post, getMe/get)
middleware/authMiddleware.js:
middleware/errorMiddleware.js:
controllers/goalController.js:
controllers/userController.js:




static folder (build folder for react): The static folder goes in the frontend/build folder, this is where react builds the static assets for deployment.






